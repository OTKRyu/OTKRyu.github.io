<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Trends in recent search</title><meta property="og:type" content="website"/><meta property="og:url" content="https://otkruy.github.io/posts/trends_in_recent_search"/><meta property="og:title" content="Trends in recent search"/><meta property="og:description" content="otkryu,search,vector search,machine learning,elasticsearch,opensearch,knn,approximate knn search"/><meta property="og:site_name" content="OTKRyu&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/a0b6e7785065566d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a0b6e7785065566d.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/_next/static/chunks/main-f813a7991d8b5eee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-898c436b230de4c1.js" defer=""></script><script src="/_next/static/chunks/996-446f66ef59abd107.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-310c95fc2645c470.js" defer=""></script><script src="/_next/static/4jpYX7FarWlmvwKNtJCkk/_buildManifest.js" defer=""></script><script src="/_next/static/4jpYX7FarWlmvwKNtJCkk/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="bg-blue-400"><div class="p-5"><nav class="bg-white flex justify-between border rounded my-3"><div class="p-2">OTKRyu</div><div class="flex"><div class="p-2 hover:underline"><a href="/">Home</a></div><div class="p-2 hover:underline"><a href="/posts">Posts</a></div><div class="p-2 hover:underline"><a href="/tags">Tags</a></div><div class="p-2 hover:underline"><a href="/about">About</a></div></div></nav><main><article class="bg-white border rounded my-3 w-full h-full p-5"><h1 class="text-3xl my-3">Trends in recent search</h1><div class="text-slate-500">Thu Jan 16 2025 20:20:36 GMT+0900 (Korean Standard Time)</div><hr class="my-3"/><div class="prose lg:prose-xl px-2 m-auto my-4 sm:my-16"><h1>Trends in recent search</h1>
<p>검색은 기본적으로 어떤 무리 안에서 내가 원하는 것을 찾는 행위이다.</p>
<p>이를 구현하는 방법은 여러 가지가 있으며,
대체로 텍스트를 이용하여 찾는 방법을 썼다.
기본적으로 무언가를 찾는 행위를 텍스트 외의 대상에 대해 수행하는 것이 쉽지 않았기 떄문이다.</p>
<p>검색을 위해서는 크게 두 가지 조건이 충족되어야 한다.</p>
<ol>
<li>검색할 실제 대상을 어떤 형태로든 컴퓨터가 이해할 수 있는 형태로 수치화가 가능해야 했으며</li>
<li>두 번째로 두 대상 간의 일치, 불일치 혹은 얼마나 일치하는지를 알 수 있는 척도가 필요하다.</li>
</ol>
<p>위와 같은 두 가지 척도를 만족시키기 쉬운 형태 중 하나는 텍스트다.</p>
<ol>
<li>텍스트는 기본적으로 컴퓨터가 이해할 수 있는 코드로 변환이 간단했고, 표준화되어 있었으며,</li>
<li>두 대상 간의 일치, 불일치 혹은 얼마나 일치하는지 판단할 척도가 간단했다. 모든 텍스트가 같으면 일치, 아니면 불일치. 텍스트 중 같은 부분이 많으면 일치율이 높고, 적으면 일치율이 낮다.</li>
</ol>
<p>반대로 이미지나 사운드에 대해서 검색을 한다고 생각해보면,
1번 조건은 생각보다 쉽게 충족된다.
이미지든 사운드이든 컴퓨터 내에서는 그냥 포맷이 있는 바이너리 파일이기 때문이다.
다만 이것은 컴퓨터에서 사용하기 편한 수치화이지 검색에 용이한 수치화는 아니다.</p>
<p>2번 조건도 생각보다 텍스트와 비슷하게 생각될지도 모른다.
텍스트처럼 공간 좌표 혹은 시계열 상에 나열된 수치들의 일치여부를 판단하면 되는게 아닌가 싶기 때문이다.
문제는 이런 가장 간단한 변환이 사람들이 인식하는 일치 혹은 불일치와 상당한 거리가 있다는 점이다.</p>
<p>이미지를 예를 들면 포맷이 같을 때에만 일치 불일치가 잘 작동했고,
포맷이 다른 순간 일치 불일치, 일치하는 정도를 알아내기가 어려워진다.
그렇다고 이미지의 모든 부분부분을 파편화하여 대조하여 일치율을 알아내면,
그 순간 연산량은 막대하게 튀어오르고 전체 대조군이 커지면서 유의미한 수준의 일치율을 알아내기 위한 조정이 필요해진다.</p>
<p>사운드도 위와 비슷하다.
음악을 그렇게 잘 찾는 샤잠조차도,
해당 서비스 원리를 설명한 포스트를 찾아보면,
사운드의 모든 부분을 기준으로 검색이 이루어지는 것이 아닌 일종의 특수한 패턴만을 검색에 활용하여 해당 기능을 서비스한다.</p>
<p>이처럼 실물에 대한 검색에 어려움이 있던 상황에서 여러 대상을 벡터로 변환할 수 있는 모델들이 등장하면서,
검색이라고 하는 행위의 본질은 변하지 않았지만 이를 이루는 이론적 배경이나 실질적인 방법은 많이 변했다.</p>
<p>오늘은 이에 대해서 실제 업무하면서 느낀 점이나 최근 검색에 대한 트렌드에 대해 글을 작성할까 한다.</p>
<h2>고전적인 방법</h2>
<p>텍스트 검색을 주 대상으로 하던 고전적인 방법은 어떤 의미로는 아주 간단했다.</p>
<p>검색하려는 텍스트와 검색 대상인 텍스트를 기준으로 부분 일치하는 부분이 얼마나 많은 지를 대조했다.</p>
<p>고전적인 관계형 DB에서는 어떤 식으로 텍스트를 분해하느냐에 따라 다르지만,
기본적으로 데이터를 파편화하여 될 수 있는 한 의미있는 토큰과 일치 여부를 판단할 수 있도록 노력했다.</p>
<p>가장 기본적인 방법은 ngram이었으며,
여기서 더 나아가서는 언어별 custom tokenizer를 사용하여 ngram보다 조금 더 의미있는 토큰을 뽑아내는 것이었다.
다만 이 방법은 결국 언어별로 다른 tokenizer를 사용해야 했으며,
전처리, 후처리 등 언어별로 다른 방법론이 필요했고 범용성이 부족했다.
최악의 경우 한국어처럼 그저 사전을 기반으로 단어를 나눠야하는 경우도 있었다.
사전은 가장 기본적인 방법이긴 하나,
확장하기도 어렵고 관리하기도 어렵다.</p>
<p>동시에 검색에 쓰이는 토큰을 잘 나누는 것뿐만이 아니라,
그 토큰이 얼마나 의미있는지에 대해서도 어떻게 평가할 것인지 평가 방법 또한 발달했다.
기본적으로 tf-idf, bm25 등으로 대표되는 방법들로,
이 토큰이 전체 집단에서 얼마나 유의미한가와 이 토큰이 얼마나 자주 등장했는가 등을 하나의 종합적인 지표로 환산하는 것이다.</p>
<p>그 외에도 빠른 검색을 위해 검색만을 위한 구조체가 고안이 되었으며,
해당 구조체를 적당한 하드웨어에서도 돌릴 수 있도록 만들고,
장애에도 튼튼하게 만들기 위해서 분산형을 채택한 솔루션이 나오는 등 검색 기술에도 다양한 방면의 노력이 계속되었다.</p>
<p>다만 위의 모든 방법은 텍스트 검색에 특화되어 있었으며,
색인을 어떻게 하느냐에 따라 검색 품질 및 검색 성능에 크게 영향을 받았다.</p>
<h2>벡터 검색</h2>
<p>텍스트 검색만으로도 만족스러운 결과를 만들어내기 쉽지 않은 시기에,
과감하게 모든 대상을 검색할 수 있는 방법이 등장했다.</p>
<p>이론적으로는 옛날옛적에도 가능했지만,
해당 이론을 구현할 하드웨어가 이제서야 받쳐줬기 때문에 등장한 기술 덕에 말이다.</p>
<p>기계 학습 기술의 비약적인 발전으로 온갖 매체에서 온갖 포맷으로 학습한 모델을 통해,
온갖 데이터를 하나의 일관된 포맷으로 변경하는 것이 가능해졌다.
바로 벡터 포맷으로 변경하는 것 말이다.
이로 인해 이미지도 텍스트도 사운드도 모두 한 번에 검색하는 것까지 가능해졌다.</p>
<p>이를 통해서 더 이상 검색 품질을 위해서 더 고도화하고 노력하는 것은 부질없는 짓이 되었다.
가장 유의미하고 정확한 하나의 값이 도출되었기 때문이다.
바로 벡터 유사도이다.
벡터 간 유사도를 구하는 기준(norm)은 여러 가지를 사용할 수 있기는 하지만,
결국 해당 기준을 통하여 구한 값 자체는 어떤 경우에도 하나의 값으로 귀결되었고 더 이상 고민할 필요가 없었다.</p>
<p>텍스트 검색에서 빠른 응답 시간을 위해 고안되었던 것들이,
벡터 검색에서도 근사 knn 벡터 검색 등의 이름으로 많은 데이터 안에서 원하는 데이터를 찾기 위한 구조에 대한 발전이 이루어졌다.</p>
<h2>비교</h2>
<p>위 두 개의 설명만 보면 벡터 검색은 텍스트 검색을 뛰어넘는 더 상위호환의 방법처럼 보인다.
현실은 그렇지만은 않다.</p>
<p>벡터 검색은 기본적으로 현실의 데이터를 벡터로 변환시켜줄 모델이 필요하다.
이 부분부터가 고비이다.
성능을 위해 자체적으로 모델을 튜닝할 수 있는 기업은 사실상 많지 않으며,
빅 테크 기업에서 제공하는 범용 모델을 사용한다 하더라도 그 값이 싸지 않다.
즉 벡터 검색을 계속 유지관리한다는 것은 MLOps 사이클을 유지관리할 수 있는 능력이 있거나,
비용을 지불할 수 있는 상황이어야 한다는 것이다.
그에 반해 텍스트 검색은 비용측면에서는 꽤나 싸다.
대부분 어떤 솔루션을 구매하거나 오픈 소스를 쓰면 꽤 괜찮게 구현되어 있는 경우가 있다.</p>
<p>그리고 벡터 검색 결과를 이해하고 싶다면 모델 또한 이해해야한다.
왜냐하면 벡터 검색 결과로 나온 결과물들이 도출된 곳은 벡터 값들 뿐이기 때문이다.
물론 해당 벡터 값이 어느 소스에서 도출되었는지,
모델이 어떤 식으로 변환하는 지에 대해서 함께 알고 해석한다면 가능할 수는 있다.
다만 이는 검색 담당자, 모델 담당자, 원본 데이터 담당자의 지식이 한 곳에 모였을 때나 가능하다.
이 모든 역할을 한 사람이 한다면 정확히 이해하고 있을 수도 있지만,
정확히 이해한다고 하더라도 해당 검색의 근거를 하나하나 집어보러 다니는 것만으로도 꽤나 시간이 걸리는 일이다.
그에 반해 텍스트 검색은 검색 결과에 대해 생각보다 친절한 설명도 함께 제공하는 경우가 있다.</p>
<h2>결론</h2>
<p>현재 직장에서도 그렇지만,
검색에도 최고의 방법이라는 것이 잘 없다고 느낀다.</p>
<p>결국 고전적인 검색 방식이 적합한 곳에는 고전적인 검색 방식이 쓰여야하며,
벡터 검색이 필요한 데이터에 대해서는 벡터 검색을 써야한다.
어떨 때는 두 방법을 모두 사용하여야만 비즈니스에 필요한 사항을 충족할 수도 있다.</p>
<p>엔지니어가 하는 일들이 대체로 그렇지만,
최고의 방법을 찾는게 아닌 현재 상황의 최적의 방법을 찾아야한다는 점이 어떨 때는 더 어렵게 느껴지기도 한다.</p>
<h2>여담</h2>
<p>추가로 검색이란 포지션 자체도 때로는 참 애매하다는 생각이 든다.</p>
<p>검색이 핵심 기능이 아닌 회사에는 검색 관련 기술을 아는 사람이 적다.
적어도 내 직장에는 검색 관련 일을 하는 사람이 조직 내에 많지가 않다.</p>
<p>요즘 RAG같은 방법론을 구현하기 위해서라도 검색 관련 수요는 지속적으로 있긴 한데,
많은 사람이 필요한 건 아니다보니 담당자가 비즈니스적으로 깊게 관여되기가 어렵다.</p>
<p>검색이 프로덕트의 핵심적인 부분이 되면 결국 점수를 매기는 로직이나,
검색 대상 등에 대한 세밀한 조정이 필요한데,
이는 결국 비즈니스 로직이 깊게 엮일 수 밖에 없는 형태이다.
그런데 검색 관련 인력은 적으니 비즈니스 로직과 연관된 조직보다는 다른 조직에서 지원형태로 나가는 경우가 많은 것이다.
이러면 검색 관련 기술을 지원은 받을 수 있어도,
검색 기능이 필요한 부서에서 정말 중요한 검색 로직은 상세히 연동되기가 어렵다.
그렇다고 반대로 검색 기술은 없는 부서에서 검색 기능을 만들면 비즈니스 로직은 잘 반영되어 있더라도,
검색 품질을 일정 수준 이상으로 끌어올리는 것이 쉽지 않다.</p>
<p>제일 좋은 형태는 검색이 필요한 부서에 검색 기술을 가진 사람이 같이 있는 것이겠지만,
생각보다 해당 조건이 충족된 케이스는 보기 어렵다.</p>
<p>회사에서도 여러 생각을 하면서 인사조치를 하겠지만서도,
검색이 잘 이루어지게 하기 위한 검색 인력의 위치라는 것이 참 애매하단 생각이 든다.</p>
</div></article></main><footer class="bg-white flex justify-center border rounded my-2"><div class="m-2"><a href="mailto:appn12@gmail.com"><img src="/images/email_icon.png" width="30" height="30"/></a></div><div class="m-2"><a href="https://github.com/OTKRyu"><img src="/images/GitHub-Mark-32px.png" width="30" height="30"/></a></div></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"trends_in_recent_search","postData":{"id":"trends_in_recent_search","contentHtml":"\u003ch1\u003eTrends in recent search\u003c/h1\u003e\n\u003cp\u003e검색은 기본적으로 어떤 무리 안에서 내가 원하는 것을 찾는 행위이다.\u003c/p\u003e\n\u003cp\u003e이를 구현하는 방법은 여러 가지가 있으며,\n대체로 텍스트를 이용하여 찾는 방법을 썼다.\n기본적으로 무언가를 찾는 행위를 텍스트 외의 대상에 대해 수행하는 것이 쉽지 않았기 떄문이다.\u003c/p\u003e\n\u003cp\u003e검색을 위해서는 크게 두 가지 조건이 충족되어야 한다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e검색할 실제 대상을 어떤 형태로든 컴퓨터가 이해할 수 있는 형태로 수치화가 가능해야 했으며\u003c/li\u003e\n\u003cli\u003e두 번째로 두 대상 간의 일치, 불일치 혹은 얼마나 일치하는지를 알 수 있는 척도가 필요하다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e위와 같은 두 가지 척도를 만족시키기 쉬운 형태 중 하나는 텍스트다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e텍스트는 기본적으로 컴퓨터가 이해할 수 있는 코드로 변환이 간단했고, 표준화되어 있었으며,\u003c/li\u003e\n\u003cli\u003e두 대상 간의 일치, 불일치 혹은 얼마나 일치하는지 판단할 척도가 간단했다. 모든 텍스트가 같으면 일치, 아니면 불일치. 텍스트 중 같은 부분이 많으면 일치율이 높고, 적으면 일치율이 낮다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e반대로 이미지나 사운드에 대해서 검색을 한다고 생각해보면,\n1번 조건은 생각보다 쉽게 충족된다.\n이미지든 사운드이든 컴퓨터 내에서는 그냥 포맷이 있는 바이너리 파일이기 때문이다.\n다만 이것은 컴퓨터에서 사용하기 편한 수치화이지 검색에 용이한 수치화는 아니다.\u003c/p\u003e\n\u003cp\u003e2번 조건도 생각보다 텍스트와 비슷하게 생각될지도 모른다.\n텍스트처럼 공간 좌표 혹은 시계열 상에 나열된 수치들의 일치여부를 판단하면 되는게 아닌가 싶기 때문이다.\n문제는 이런 가장 간단한 변환이 사람들이 인식하는 일치 혹은 불일치와 상당한 거리가 있다는 점이다.\u003c/p\u003e\n\u003cp\u003e이미지를 예를 들면 포맷이 같을 때에만 일치 불일치가 잘 작동했고,\n포맷이 다른 순간 일치 불일치, 일치하는 정도를 알아내기가 어려워진다.\n그렇다고 이미지의 모든 부분부분을 파편화하여 대조하여 일치율을 알아내면,\n그 순간 연산량은 막대하게 튀어오르고 전체 대조군이 커지면서 유의미한 수준의 일치율을 알아내기 위한 조정이 필요해진다.\u003c/p\u003e\n\u003cp\u003e사운드도 위와 비슷하다.\n음악을 그렇게 잘 찾는 샤잠조차도,\n해당 서비스 원리를 설명한 포스트를 찾아보면,\n사운드의 모든 부분을 기준으로 검색이 이루어지는 것이 아닌 일종의 특수한 패턴만을 검색에 활용하여 해당 기능을 서비스한다.\u003c/p\u003e\n\u003cp\u003e이처럼 실물에 대한 검색에 어려움이 있던 상황에서 여러 대상을 벡터로 변환할 수 있는 모델들이 등장하면서,\n검색이라고 하는 행위의 본질은 변하지 않았지만 이를 이루는 이론적 배경이나 실질적인 방법은 많이 변했다.\u003c/p\u003e\n\u003cp\u003e오늘은 이에 대해서 실제 업무하면서 느낀 점이나 최근 검색에 대한 트렌드에 대해 글을 작성할까 한다.\u003c/p\u003e\n\u003ch2\u003e고전적인 방법\u003c/h2\u003e\n\u003cp\u003e텍스트 검색을 주 대상으로 하던 고전적인 방법은 어떤 의미로는 아주 간단했다.\u003c/p\u003e\n\u003cp\u003e검색하려는 텍스트와 검색 대상인 텍스트를 기준으로 부분 일치하는 부분이 얼마나 많은 지를 대조했다.\u003c/p\u003e\n\u003cp\u003e고전적인 관계형 DB에서는 어떤 식으로 텍스트를 분해하느냐에 따라 다르지만,\n기본적으로 데이터를 파편화하여 될 수 있는 한 의미있는 토큰과 일치 여부를 판단할 수 있도록 노력했다.\u003c/p\u003e\n\u003cp\u003e가장 기본적인 방법은 ngram이었으며,\n여기서 더 나아가서는 언어별 custom tokenizer를 사용하여 ngram보다 조금 더 의미있는 토큰을 뽑아내는 것이었다.\n다만 이 방법은 결국 언어별로 다른 tokenizer를 사용해야 했으며,\n전처리, 후처리 등 언어별로 다른 방법론이 필요했고 범용성이 부족했다.\n최악의 경우 한국어처럼 그저 사전을 기반으로 단어를 나눠야하는 경우도 있었다.\n사전은 가장 기본적인 방법이긴 하나,\n확장하기도 어렵고 관리하기도 어렵다.\u003c/p\u003e\n\u003cp\u003e동시에 검색에 쓰이는 토큰을 잘 나누는 것뿐만이 아니라,\n그 토큰이 얼마나 의미있는지에 대해서도 어떻게 평가할 것인지 평가 방법 또한 발달했다.\n기본적으로 tf-idf, bm25 등으로 대표되는 방법들로,\n이 토큰이 전체 집단에서 얼마나 유의미한가와 이 토큰이 얼마나 자주 등장했는가 등을 하나의 종합적인 지표로 환산하는 것이다.\u003c/p\u003e\n\u003cp\u003e그 외에도 빠른 검색을 위해 검색만을 위한 구조체가 고안이 되었으며,\n해당 구조체를 적당한 하드웨어에서도 돌릴 수 있도록 만들고,\n장애에도 튼튼하게 만들기 위해서 분산형을 채택한 솔루션이 나오는 등 검색 기술에도 다양한 방면의 노력이 계속되었다.\u003c/p\u003e\n\u003cp\u003e다만 위의 모든 방법은 텍스트 검색에 특화되어 있었으며,\n색인을 어떻게 하느냐에 따라 검색 품질 및 검색 성능에 크게 영향을 받았다.\u003c/p\u003e\n\u003ch2\u003e벡터 검색\u003c/h2\u003e\n\u003cp\u003e텍스트 검색만으로도 만족스러운 결과를 만들어내기 쉽지 않은 시기에,\n과감하게 모든 대상을 검색할 수 있는 방법이 등장했다.\u003c/p\u003e\n\u003cp\u003e이론적으로는 옛날옛적에도 가능했지만,\n해당 이론을 구현할 하드웨어가 이제서야 받쳐줬기 때문에 등장한 기술 덕에 말이다.\u003c/p\u003e\n\u003cp\u003e기계 학습 기술의 비약적인 발전으로 온갖 매체에서 온갖 포맷으로 학습한 모델을 통해,\n온갖 데이터를 하나의 일관된 포맷으로 변경하는 것이 가능해졌다.\n바로 벡터 포맷으로 변경하는 것 말이다.\n이로 인해 이미지도 텍스트도 사운드도 모두 한 번에 검색하는 것까지 가능해졌다.\u003c/p\u003e\n\u003cp\u003e이를 통해서 더 이상 검색 품질을 위해서 더 고도화하고 노력하는 것은 부질없는 짓이 되었다.\n가장 유의미하고 정확한 하나의 값이 도출되었기 때문이다.\n바로 벡터 유사도이다.\n벡터 간 유사도를 구하는 기준(norm)은 여러 가지를 사용할 수 있기는 하지만,\n결국 해당 기준을 통하여 구한 값 자체는 어떤 경우에도 하나의 값으로 귀결되었고 더 이상 고민할 필요가 없었다.\u003c/p\u003e\n\u003cp\u003e텍스트 검색에서 빠른 응답 시간을 위해 고안되었던 것들이,\n벡터 검색에서도 근사 knn 벡터 검색 등의 이름으로 많은 데이터 안에서 원하는 데이터를 찾기 위한 구조에 대한 발전이 이루어졌다.\u003c/p\u003e\n\u003ch2\u003e비교\u003c/h2\u003e\n\u003cp\u003e위 두 개의 설명만 보면 벡터 검색은 텍스트 검색을 뛰어넘는 더 상위호환의 방법처럼 보인다.\n현실은 그렇지만은 않다.\u003c/p\u003e\n\u003cp\u003e벡터 검색은 기본적으로 현실의 데이터를 벡터로 변환시켜줄 모델이 필요하다.\n이 부분부터가 고비이다.\n성능을 위해 자체적으로 모델을 튜닝할 수 있는 기업은 사실상 많지 않으며,\n빅 테크 기업에서 제공하는 범용 모델을 사용한다 하더라도 그 값이 싸지 않다.\n즉 벡터 검색을 계속 유지관리한다는 것은 MLOps 사이클을 유지관리할 수 있는 능력이 있거나,\n비용을 지불할 수 있는 상황이어야 한다는 것이다.\n그에 반해 텍스트 검색은 비용측면에서는 꽤나 싸다.\n대부분 어떤 솔루션을 구매하거나 오픈 소스를 쓰면 꽤 괜찮게 구현되어 있는 경우가 있다.\u003c/p\u003e\n\u003cp\u003e그리고 벡터 검색 결과를 이해하고 싶다면 모델 또한 이해해야한다.\n왜냐하면 벡터 검색 결과로 나온 결과물들이 도출된 곳은 벡터 값들 뿐이기 때문이다.\n물론 해당 벡터 값이 어느 소스에서 도출되었는지,\n모델이 어떤 식으로 변환하는 지에 대해서 함께 알고 해석한다면 가능할 수는 있다.\n다만 이는 검색 담당자, 모델 담당자, 원본 데이터 담당자의 지식이 한 곳에 모였을 때나 가능하다.\n이 모든 역할을 한 사람이 한다면 정확히 이해하고 있을 수도 있지만,\n정확히 이해한다고 하더라도 해당 검색의 근거를 하나하나 집어보러 다니는 것만으로도 꽤나 시간이 걸리는 일이다.\n그에 반해 텍스트 검색은 검색 결과에 대해 생각보다 친절한 설명도 함께 제공하는 경우가 있다.\u003c/p\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003cp\u003e현재 직장에서도 그렇지만,\n검색에도 최고의 방법이라는 것이 잘 없다고 느낀다.\u003c/p\u003e\n\u003cp\u003e결국 고전적인 검색 방식이 적합한 곳에는 고전적인 검색 방식이 쓰여야하며,\n벡터 검색이 필요한 데이터에 대해서는 벡터 검색을 써야한다.\n어떨 때는 두 방법을 모두 사용하여야만 비즈니스에 필요한 사항을 충족할 수도 있다.\u003c/p\u003e\n\u003cp\u003e엔지니어가 하는 일들이 대체로 그렇지만,\n최고의 방법을 찾는게 아닌 현재 상황의 최적의 방법을 찾아야한다는 점이 어떨 때는 더 어렵게 느껴지기도 한다.\u003c/p\u003e\n\u003ch2\u003e여담\u003c/h2\u003e\n\u003cp\u003e추가로 검색이란 포지션 자체도 때로는 참 애매하다는 생각이 든다.\u003c/p\u003e\n\u003cp\u003e검색이 핵심 기능이 아닌 회사에는 검색 관련 기술을 아는 사람이 적다.\n적어도 내 직장에는 검색 관련 일을 하는 사람이 조직 내에 많지가 않다.\u003c/p\u003e\n\u003cp\u003e요즘 RAG같은 방법론을 구현하기 위해서라도 검색 관련 수요는 지속적으로 있긴 한데,\n많은 사람이 필요한 건 아니다보니 담당자가 비즈니스적으로 깊게 관여되기가 어렵다.\u003c/p\u003e\n\u003cp\u003e검색이 프로덕트의 핵심적인 부분이 되면 결국 점수를 매기는 로직이나,\n검색 대상 등에 대한 세밀한 조정이 필요한데,\n이는 결국 비즈니스 로직이 깊게 엮일 수 밖에 없는 형태이다.\n그런데 검색 관련 인력은 적으니 비즈니스 로직과 연관된 조직보다는 다른 조직에서 지원형태로 나가는 경우가 많은 것이다.\n이러면 검색 관련 기술을 지원은 받을 수 있어도,\n검색 기능이 필요한 부서에서 정말 중요한 검색 로직은 상세히 연동되기가 어렵다.\n그렇다고 반대로 검색 기술은 없는 부서에서 검색 기능을 만들면 비즈니스 로직은 잘 반영되어 있더라도,\n검색 품질을 일정 수준 이상으로 끌어올리는 것이 쉽지 않다.\u003c/p\u003e\n\u003cp\u003e제일 좋은 형태는 검색이 필요한 부서에 검색 기술을 가진 사람이 같이 있는 것이겠지만,\n생각보다 해당 조건이 충족된 케이스는 보기 어렵다.\u003c/p\u003e\n\u003cp\u003e회사에서도 여러 생각을 하면서 인사조치를 하겠지만서도,\n검색이 잘 이루어지게 하기 위한 검색 인력의 위치라는 것이 참 애매하단 생각이 든다.\u003c/p\u003e\n","title":"Trends in recent search","date":"2024-07-15","tags":["search","vector search","machine learning","elasticsearch","opensearch","knn","approximate knn search"]}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"trends_in_recent_search"},"buildId":"4jpYX7FarWlmvwKNtJCkk","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>