---
title: "Opensearch Blow Experience"
date: "2025-04-27"
tags:
  - opensearch
  - OOM
---

# Opensearch Blow Experience

## 문제

최근에 개발환경에서 오픈서치를 터쳐본 경험이 있어서 공유해본다.
대단한 것은 아니고 cpu가 100를 쳐가지고 제대로 응답할 수 없게 된 일이었다.

## 해결

일단 cpu 가 100을 쳤으니 가장 단순한 방법으로 아래 두 가지 방법을 썼다.
1. 일단 cpu가 가용량이 더 많은 인스턴스 타입으로 바꾸었다.
2. 인덱스가 3개의 노드 중 하나에만 할당이 되어있길래 변경하여 3개 노드에 전부 골고루 퍼져서 연산할 수 있도록 복제본을 추가했다.

일단 해결은 1번만으로도 해결이 되었다.

## 원인 파악

다만 해결을 하고 나서 생각해보니 좀 이상했던게,
아무리 개발환경에서 작은 인스턴스를 썼다지만 cpu가 100쳐서 죽을만큼의 트래픽이 들어온 적이 없었다.

그래서 추가로 들어왔던 요청이 어떤 것인지를 뒤지다보니,
거대한 벡터 구조체를 사용해야하는 요청이 들어왔었다.

다만 이 때도 이해가 안 갔던 것이 거대한 벡터 구조체를 이용한 요청이 왔다면,
해당 구조체를 쓰기 위해 메모리가 터지는 게 정상으로 보였는데 정작 터진 건 cpu였다.

jvm에 대해서 java를 깊게 써본 적이 없어서 정확히는 모르지만,
jvm도 메모리 사용 수위가 높아지면 OOM으로 터지는 사례는 다른 팀에서 몇 번 봤어서 더더욱 이해가 안 갔었다.

그렇게 원인이 뭔지 정확히 모르겠는 와중에 세운 가설은 아래와 같았다.

1. 거대한 벡터 구조체를 필요로 하는 요청이 들어왔다.
2. 하지만 해당 인스턴스와 jvm 설정으로는 해당 거대 벡터 구조체를 메모리에 올릴 여력이 없었다.
3. 그리고 오픈서치는 OOM을 피하기 위해 메모리 허용량 이상을 쓰려고 하면 메모리를 스왑한다.
4. 이로 인해 하드와 메모리 사이의 데이터 교환이 지속적으로 일어나고 이를 처리하기 위해 cpu를 점점 더 많이 쓰게 된다.
5. 그 결과 cpu 가 100퍼센트에 도달하고 이 때문에 정상적인 처리가 이루어질 수 없었다.

사실 위 가설에 몇 가지 확인되지 않은 부분들이 있어서 여전히 정확히 맞는지는 모르겠다.

다만 위와 같은 경우도 있을 수 있기 때문에,
메모리를 많이 쓰는 서비스인데도 불구하고 cpu가 많이 튀는 경우가 있다면,
cpu가 아니라 메모리를 의심해보자.
