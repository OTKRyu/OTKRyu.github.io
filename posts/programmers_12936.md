---
title: "programmers_12936"
date: "2022-09-19"
tags:
  - algorithm
  - python
  - programmers
---

# programmers_12936

## problem

줄 서는 방법[https://school.programmers.co.kr/learn/courses/30/lessons/12936]

## answer

```
def solution(n, k):
    # 팩토리얼 계산용
    facto = [1 for i in range(n+1)]
    for i in range(1, n+1):
        facto[i] = facto[i-1] * i

    # 사용한 숫자 체크용
    check = [1 for i in range(n+1)]
    answer = []

    # 한 자리씩 지나가면서 결정
    # i가 해당하는 자리
    # cnt가 남은 수중 몇번째로 작은 수가 들어갈지
    for i in range(n):
        cnt = 0
        # 들어갈 수 있는 cnt가 얼마인지 알아냄
        while 1:
            if cnt * facto[n-i-1] < k <= (cnt + 1) * facto[n-i-1]:
                k -= cnt * facto[n-i-1]
                cnt += 1
                break
            else:
                cnt += 1

        # cnt에 해당하는 작은 순번의 수가 무엇인지 찾아냄
        for i in range(1, len(check)):
            if check[i] == 1:
                cnt -= 1
                if cnt == 0:
                    answer.append(i)
                    check[i] = 0
                    break
    return answer
```

## explanation

가장 기본적인 접근은 순열을 만들면서 k에 해당하는 순번쯤에서 멈추는 것이다.
파이썬 같은 경우 순열조차 쉽게 생성할 수 있으므로 한번쯤 시도해볼 만한 방법이다.

```
from itertools import permutations
```

다만 당연하게도 실패한다. 순열을 구현해봤다면 순열을 도중에 그만두지 않는다고 할 시 n!만큼의 시간이 걸리기 때문에 문제에서 요구하는 시간 안에는 도저히 해낼 수가 없다.

그렇다면 순열을 만들지 않고 순번만 구하면 된다는 접근을 시도해야한다.

문제의 조건에서 볼 수 있듯이 이 문제에서는 순열을 생성하는데에 순서가 있고,
이를 따라간다는 조건하에 언제쯤 어떤 순열이 나올지를 알 수가 있다.

- [1,2,3]
- [1,3,2]
- [2,1,3]
- [2,3,1]
- [3,1,2]
- [3,2,1]

앞에서부터 한 자리씩 천천히 보면 뒤에 남은 가짓수가 다 떨어지기 전까지는 앞자리가 변하지 않는 것을 볼 수 있다.

즉 첫 번째 자리는 남은 뒤의 자리 2,3번 자리의 경우의 수(2!)가 지나가기 전까지는 바뀌지 않는다.
이를 통해서 주어진 k에 해당할 순열을 좁혀나갈 수 있다.

예시와 함께 살펴보자면, 첫 번째 자리는 2!의 순번동안 유지가 된다.
고로 남은 k에서 2!씩 빼가면서 더 이상 뺄 수 없을 시점에 숫자가 첫 번째 자리를 차지하게된다.
(이 때 2!를 뺐을 때 0이 되는 경우는 현재의 숫자의 순번이 아닌 다음 숫자의 순번이므로 이 점을 주의해야한다)

이 첫 번째 자리에서 해준 방식으로 2번째, 3번째 ... 자리를 확정해주면 된다.
다만 달라지는 점은 이전 자리에서 쓴 숫자는 쓸 수 없기 때문에, 남은 숫자중에서 작은 숫자를 정해주면 된다.(순열 생성 순번이 남은 작은수에서 큰수순으로 진행되기 때문에)

사실 이 문제는 고등학교를 다녔다면 지겹도록 봤을 군수열문제인데, 코드로 생각해보면 어떻게 풀어야할지 한번 고민하게 되는 문제다.
