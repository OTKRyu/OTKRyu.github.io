<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Kaizen 2</title><meta property="og:type" content="website"/><meta property="og:url" content="https://otkruy.github.io/posts/kaizen_2"/><meta property="og:title" content="Kaizen 2"/><meta property="og:description" content="otkryu,thread,async,server,continuous improvement,memory leak"/><meta property="og:site_name" content="OTKRyu&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/712db0cf82bf277b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/712db0cf82bf277b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/_next/static/chunks/main-f813a7991d8b5eee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-898c436b230de4c1.js" defer=""></script><script src="/_next/static/chunks/996-446f66ef59abd107.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-b11a75725d7639b5.js" defer=""></script><script src="/_next/static/d0vDU4IyHdGMOCCzVf7DM/_buildManifest.js" defer=""></script><script src="/_next/static/d0vDU4IyHdGMOCCzVf7DM/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="bg-blue-400"><div class="p-5"><nav class="bg-white flex justify-between border rounded my-3"><div class="p-2">OTKRyu</div><div class="flex"><div class="p-2 hover:underline"><a href="/">Home</a></div><div class="p-2 hover:underline"><a href="/posts">Posts</a></div><div class="p-2 hover:underline"><a href="/tags">Tags</a></div><div class="p-2 hover:underline"><a href="/about">About</a></div></div></nav><main><article class="bg-white border rounded my-3 w-full h-full p-5"><h1 class="text-3xl my-3">Kaizen 2</h1><div class="text-slate-500">Sat Jan 17 2026 01:26:49 GMT+0900 (Korean Standard Time)</div><hr class="my-3"/><div class="prose lg:prose-xl px-2 m-auto my-4 sm:my-16"><h1>kaizen 2</h1>
<p>kaizen 1 편에서 이어진다.</p>
<h2>기능별 서버, 인프라 분리</h2>
<p>사실 이전의 모든 과정들로 더 이상 메모리 이슈는 되지 않았다. 어느 정도 안전한 수위를 유지하게 되었으며, 메모리 알람도 더 이상 안 나게 되었다.
다만 그럼에도 불구하고 서버가 오래 떠 있으면, 예전처럼 급격하게는 아니지만 메모리 수치가 슬금슬금 올라가긴 했다.</p>
<p>이제 이게 시급한 이슈가 아니게 된 시점에서 이걸 고치기 위해서 뭘 해야겠다고 생각하지는 않았고,
그냥 해당 서버에 이런저런 기능이 덕지덕지 붙은 형태였기 때문에,
대 분류 기준으로 서버를 좀 나눠야 양 쪽 서비스가 목적대로 따로 운영할 수 있다는 생각이 들었다.</p>
<p>그래서 기존에 이미지 처리 기능 및 텍스트 기능 처리 붙어있던 걸 인프라랑 소스 코드 분리해서 나누는 작업을 하게 됐다.</p>
<p>이 작업도 순탄치는 않았지만 어찌저찌 끝내고 나니까 그제서야 비로소 진짜 메모리가 계속 올라가는 부분이 이미지 처리에만 있다는 걸 확인할 수 있게 됐다.</p>
<h2>쓰레드풀 -> 비동기</h2>
<p>이쯤되면 궁금해서라도 이미지 처리 기능에는 왜 누수가 있는 걸까가 궁금해져서 고쳐보려고 했었다만,
메모리 누수가 있다고 말하기는 애매했었다.
정말 작은 정도의 메모리 누수가 요청마다 있었어서, gc가 안 돌아서 남았던 부분이란 부분은 죄다 변경했었는데,
고쳐지진 않았다.</p>
<p>그래서 더 찾아보지는 않고, 예전부터 고치고 싶었던 threadpool로 구현된 병렬성을 비동기로 바꾸는 작업을 진행했다.
해당 서버에서 하는 작업의 대부분은 I/O 작업이었는데,
이걸 threadpool 로 성능 유지를 하다보니 몇 가지 추가 설정도 해줘야되고 성능이 그렇게 좋지도 않았다.</p>
<p>어차피 I/O 기반이면 비동기로 해도 문제 없을 거고,
블록킹 있을만큼 거대한 작업도 딱히 보이지 않았다.</p>
<p>그래서 비동기로 변경했었고 솔직한 마음으로는 성능 개선도 좀 있기를 바랐다.
근데 생각보다 자원 활용율도 크게 안 늘었다.
그냥 로직 단순화랑 병렬성 구현이 일관되게 바뀌었다는 점에 만족해야했다.</p>
<p>그리고 싱글 쓰레드로 바꾸니까 예상치 못한 수확으로 메모리 누수도 사라졌다.</p>
<p>쓰레드는 프로세스처럼 사용할 때 돼서 초기화되는 것도 아니라서 이거 왜 없어진 건지 확실하게 알 수는 없지만,
지금 그나마 의심이 가는건 GC가 일정 횟수의 연산이 일어난 이후에나 이루어지는데,
기존에 쓰레드를 여러 개로 쪼개놨을 때는 GC 연산이 트리거 되는 연산이 잘 이루어지지 않게 되는 뭔가가 있었던 게 아닐까 정도로 생각하고 있다.
어찌됐건 쓰레드도 독자 메모리 쓰는 게 좀 있으니까 그게 줄어서 그렇게 보이는 건가 싶기도 하고.</p>
<h2>전체 데이터 갱신 -> 증분 데이터 갱신</h2>
<p>kaizen 1에서도 말했다시피 해당 서비스는 꽤 큰 데이터를 서버에 들고 있어야되는 서비스여서,
변경사항이 있을 때마다 꽤나 큰 데이터를 DB로부터 중계서버를 거쳐서 가져오고,
이를 서버 행동에 반영을 해야했다.</p>
<p>이게 어떤 의미에서는 참 화끈했는데,
큰 데이터를 가져오지만 그걸 일일히 변했는지 같은 거는 체크 안 하고 그냥 다 새로 갱신해버렸다.</p>
<p>그렇다보니까 최대 장점은 단순한 구현이었는데,
문제는 이게 데이터가 너무 커져서 해당 연산을 위처럼 구현하면,
해당 시간동안 처리가 밀려서 원하는 레이턴시가 나올 수가 없었다.</p>
<p>그래서 이걸 해결하기 위해서 아래 두 가지 정도가 고려되었다.</p>
<ul>
<li>증분 변경을 통해 데이터 최종일관성정도만 지키기</li>
<li>프로세스간 공유데이터가 있는데 이거 좀 더 빠른 방법으로 교체하기</li>
</ul>
<p>위처럼 생각은 했었지만 이런저런 일이 있어서 결국 마지막 작업은 내가 하진 않았다.</p>
<h2>소회</h2>
<p>해당 서비스는 일단 회사 내에서 많이 쓰이는 서비스였고,
고칠만한 충분한 가치가 있는 서비스였으며,
내가 맡아본 가장 많은 트래픽을 받는 서비스였다.</p>
<p>처음에 인수인계 받았을 때는 트래픽 많이 받아야되는 서버라는 점과 장애 생기면 여러 군데에 영향이 가는 서비스라는 게 부담이기도 했지만,
하다보니까 좋은 방향으로든 안 좋은 방향으로든 익숙해졌다.</p>
<p>나는 애시당초 성향이 더 이상 안 쓰이거나, 쓰지 않을 기능이면 다 지워버리는 게 모토고,
어떤 기능을 구현하는 데 더 "멋진" 방법이 있더라도 간단한 방법이 최고라고 생각하는 편이라,
처음부터 내가 짰더라면 아마 이런 경험을 해볼 수 없었을 것이다.</p>
<p>이 서비스 맡고 있는 동안은 불안해서라도 시간 비면 모니터링 툴 보고, 알람 조정하고, 주말에 어디 갈 때도 노트북을 들고 다녔었다.
아직도 고칠 곳이 많이 있는 서비스였고 다 고치지 못해 아쉽기도 하지만,
이 서비스 유지보수하고 개발하면서 정말 많이 배우고 많이 경험해볼 수 있었다.</p>
<p>처음으로 <code>그 때는 맞고 지금은 틀리다.</code> 같은 말에 대해서 체험해볼 수 있었고,
데이터 양이 늘어나는 것만으로도 고려해야되는 게 점점 많아지는 것도 처음 겪어봤다.</p>
<p>좋은 사수 분과 이런 서비스를 책임져볼 수 있었던 것이 어쩌면 이 회사에 가장 감사한 부분일지도 모르겠다는 생각을 한다.</p>
</div><div class="mt-8 flex justify-center"><a href="/posts/revisit" class="inline-flex items-center gap-2 rounded-md border border-gray-300 px-5 py-3 text-lg text-gray-700 hover:bg-gray-100 hover:text-black transition">👉 Related post :<span class="font-semibold text-blue-600 hover:text-blue-800 hover:underline transition-colors">revisit</span></a></div></article></main><footer class="bg-white flex justify-center border rounded my-2"><div class="m-2"><a href="mailto:appn12@gmail.com"><img src="/images/email_icon.png" width="30" height="30"/></a></div><div class="m-2"><a href="https://github.com/OTKRyu"><img src="/images/GitHub-Mark-32px.png" width="30" height="30"/></a></div></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"kaizen_2","postData":{"id":"kaizen_2","contentHtml":"\u003ch1\u003ekaizen 2\u003c/h1\u003e\n\u003cp\u003ekaizen 1 편에서 이어진다.\u003c/p\u003e\n\u003ch2\u003e기능별 서버, 인프라 분리\u003c/h2\u003e\n\u003cp\u003e사실 이전의 모든 과정들로 더 이상 메모리 이슈는 되지 않았다. 어느 정도 안전한 수위를 유지하게 되었으며, 메모리 알람도 더 이상 안 나게 되었다.\n다만 그럼에도 불구하고 서버가 오래 떠 있으면, 예전처럼 급격하게는 아니지만 메모리 수치가 슬금슬금 올라가긴 했다.\u003c/p\u003e\n\u003cp\u003e이제 이게 시급한 이슈가 아니게 된 시점에서 이걸 고치기 위해서 뭘 해야겠다고 생각하지는 않았고,\n그냥 해당 서버에 이런저런 기능이 덕지덕지 붙은 형태였기 때문에,\n대 분류 기준으로 서버를 좀 나눠야 양 쪽 서비스가 목적대로 따로 운영할 수 있다는 생각이 들었다.\u003c/p\u003e\n\u003cp\u003e그래서 기존에 이미지 처리 기능 및 텍스트 기능 처리 붙어있던 걸 인프라랑 소스 코드 분리해서 나누는 작업을 하게 됐다.\u003c/p\u003e\n\u003cp\u003e이 작업도 순탄치는 않았지만 어찌저찌 끝내고 나니까 그제서야 비로소 진짜 메모리가 계속 올라가는 부분이 이미지 처리에만 있다는 걸 확인할 수 있게 됐다.\u003c/p\u003e\n\u003ch2\u003e쓰레드풀 -\u003e 비동기\u003c/h2\u003e\n\u003cp\u003e이쯤되면 궁금해서라도 이미지 처리 기능에는 왜 누수가 있는 걸까가 궁금해져서 고쳐보려고 했었다만,\n메모리 누수가 있다고 말하기는 애매했었다.\n정말 작은 정도의 메모리 누수가 요청마다 있었어서, gc가 안 돌아서 남았던 부분이란 부분은 죄다 변경했었는데,\n고쳐지진 않았다.\u003c/p\u003e\n\u003cp\u003e그래서 더 찾아보지는 않고, 예전부터 고치고 싶었던 threadpool로 구현된 병렬성을 비동기로 바꾸는 작업을 진행했다.\n해당 서버에서 하는 작업의 대부분은 I/O 작업이었는데,\n이걸 threadpool 로 성능 유지를 하다보니 몇 가지 추가 설정도 해줘야되고 성능이 그렇게 좋지도 않았다.\u003c/p\u003e\n\u003cp\u003e어차피 I/O 기반이면 비동기로 해도 문제 없을 거고,\n블록킹 있을만큼 거대한 작업도 딱히 보이지 않았다.\u003c/p\u003e\n\u003cp\u003e그래서 비동기로 변경했었고 솔직한 마음으로는 성능 개선도 좀 있기를 바랐다.\n근데 생각보다 자원 활용율도 크게 안 늘었다.\n그냥 로직 단순화랑 병렬성 구현이 일관되게 바뀌었다는 점에 만족해야했다.\u003c/p\u003e\n\u003cp\u003e그리고 싱글 쓰레드로 바꾸니까 예상치 못한 수확으로 메모리 누수도 사라졌다.\u003c/p\u003e\n\u003cp\u003e쓰레드는 프로세스처럼 사용할 때 돼서 초기화되는 것도 아니라서 이거 왜 없어진 건지 확실하게 알 수는 없지만,\n지금 그나마 의심이 가는건 GC가 일정 횟수의 연산이 일어난 이후에나 이루어지는데,\n기존에 쓰레드를 여러 개로 쪼개놨을 때는 GC 연산이 트리거 되는 연산이 잘 이루어지지 않게 되는 뭔가가 있었던 게 아닐까 정도로 생각하고 있다.\n어찌됐건 쓰레드도 독자 메모리 쓰는 게 좀 있으니까 그게 줄어서 그렇게 보이는 건가 싶기도 하고.\u003c/p\u003e\n\u003ch2\u003e전체 데이터 갱신 -\u003e 증분 데이터 갱신\u003c/h2\u003e\n\u003cp\u003ekaizen 1에서도 말했다시피 해당 서비스는 꽤 큰 데이터를 서버에 들고 있어야되는 서비스여서,\n변경사항이 있을 때마다 꽤나 큰 데이터를 DB로부터 중계서버를 거쳐서 가져오고,\n이를 서버 행동에 반영을 해야했다.\u003c/p\u003e\n\u003cp\u003e이게 어떤 의미에서는 참 화끈했는데,\n큰 데이터를 가져오지만 그걸 일일히 변했는지 같은 거는 체크 안 하고 그냥 다 새로 갱신해버렸다.\u003c/p\u003e\n\u003cp\u003e그렇다보니까 최대 장점은 단순한 구현이었는데,\n문제는 이게 데이터가 너무 커져서 해당 연산을 위처럼 구현하면,\n해당 시간동안 처리가 밀려서 원하는 레이턴시가 나올 수가 없었다.\u003c/p\u003e\n\u003cp\u003e그래서 이걸 해결하기 위해서 아래 두 가지 정도가 고려되었다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e증분 변경을 통해 데이터 최종일관성정도만 지키기\u003c/li\u003e\n\u003cli\u003e프로세스간 공유데이터가 있는데 이거 좀 더 빠른 방법으로 교체하기\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위처럼 생각은 했었지만 이런저런 일이 있어서 결국 마지막 작업은 내가 하진 않았다.\u003c/p\u003e\n\u003ch2\u003e소회\u003c/h2\u003e\n\u003cp\u003e해당 서비스는 일단 회사 내에서 많이 쓰이는 서비스였고,\n고칠만한 충분한 가치가 있는 서비스였으며,\n내가 맡아본 가장 많은 트래픽을 받는 서비스였다.\u003c/p\u003e\n\u003cp\u003e처음에 인수인계 받았을 때는 트래픽 많이 받아야되는 서버라는 점과 장애 생기면 여러 군데에 영향이 가는 서비스라는 게 부담이기도 했지만,\n하다보니까 좋은 방향으로든 안 좋은 방향으로든 익숙해졌다.\u003c/p\u003e\n\u003cp\u003e나는 애시당초 성향이 더 이상 안 쓰이거나, 쓰지 않을 기능이면 다 지워버리는 게 모토고,\n어떤 기능을 구현하는 데 더 \"멋진\" 방법이 있더라도 간단한 방법이 최고라고 생각하는 편이라,\n처음부터 내가 짰더라면 아마 이런 경험을 해볼 수 없었을 것이다.\u003c/p\u003e\n\u003cp\u003e이 서비스 맡고 있는 동안은 불안해서라도 시간 비면 모니터링 툴 보고, 알람 조정하고, 주말에 어디 갈 때도 노트북을 들고 다녔었다.\n아직도 고칠 곳이 많이 있는 서비스였고 다 고치지 못해 아쉽기도 하지만,\n이 서비스 유지보수하고 개발하면서 정말 많이 배우고 많이 경험해볼 수 있었다.\u003c/p\u003e\n\u003cp\u003e처음으로 \u003ccode\u003e그 때는 맞고 지금은 틀리다.\u003c/code\u003e 같은 말에 대해서 체험해볼 수 있었고,\n데이터 양이 늘어나는 것만으로도 고려해야되는 게 점점 많아지는 것도 처음 겪어봤다.\u003c/p\u003e\n\u003cp\u003e좋은 사수 분과 이런 서비스를 책임져볼 수 있었던 것이 어쩌면 이 회사에 가장 감사한 부분일지도 모르겠다는 생각을 한다.\u003c/p\u003e\n","title":"Kaizen 2","date":"2025-12-10","relatedPost":"revisit","tags":["thread","async","server","continuous improvement","memory leak"]}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"kaizen_2"},"buildId":"d0vDU4IyHdGMOCCzVf7DM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>