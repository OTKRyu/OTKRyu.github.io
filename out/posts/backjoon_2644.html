<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>backjoon_2644.py</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/7b8fa7d68472dec7.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7b8fa7d68472dec7.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/_next/static/chunks/main-f813a7991d8b5eee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-898c436b230de4c1.js" defer=""></script><script src="/_next/static/chunks/664-fe1f0ac1dd157bd4.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-d509abed2dab19f4.js" defer=""></script><script src="/_next/static/3nolsCOkiLDS3NjSRQxxg/_buildManifest.js" defer=""></script><script src="/_next/static/3nolsCOkiLDS3NjSRQxxg/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="bg-blue-400"><div class="p-5"><nav class="bg-white flex justify-between border rounded my-3"><div class="p-2">OTKRyu</div><div class="flex"><div class="p-2 hover:underline"><a href="/">Home</a></div><div class="p-2 hover:underline"><a href="/posts">Posts</a></div><div class="p-2 hover:underline"><a href="/tags">Tags</a></div><div class="p-2 hover:underline"><a href="/about">About</a></div></div></nav><main><article class="bg-white border rounded my-3 w-full h-full p-5"><h1 class="text-3xl my-3">backjoon_2644.py</h1><div class="text-slate-500">Wed Oct 12 2022 22:55:32 GMT+0900 (대한민국 표준시)</div><hr class="my-3"/><div class="prose lg:prose-xl px-2 m-auto my-4 sm:my-16"><h1>backjoon_2644.py</h1>
<h2>problem</h2>
<p>촌수계산[https://www.acmicpc.net/problem/2644]</p>
<h2>answer</h2>
<div><pre><code>n = int(input())
tx, ty = map(int, input().split(&#x26;#39; &#x26;#39;))
m = int(input())
parents = {}
childs = {}
result = -1
check = [1 for i in range(n+1)]
for i in range(m):
    x, y = map(int, input().split(&#x26;#39; &#x26;#39;))
    parents[y] = x
    if childs.get(x):
        childs[x].append(y)
    else:
        childs[x] = [y]

def dfs(tx, cnt):
    global childs, parents, result, ty, check
    check[tx] = 0
    if tx == ty:
        result = cnt
        return 0
    flag = 1
    if childs.get(tx):
        for child in childs[tx]:
            if flag == 1 and check[child] == 1:
                flag = dfs(child, cnt+1)
    if parents.get(tx) and check[parents[tx]] == 1 and flag == 1:
        return dfs(parents[tx], cnt+1)
    return 1

dfs(tx, 0)
print(result)</code></pre></div>
<h2>explanation</h2>
<p>촌수계산하는 문제이다.</p>
<p>여러 방법이 있겠지만, dfs 문제로 분류되어 있어서 dfs로 풀었다.</p>
<p>주어진 조건을 보면 일종의 트리를 만들 수 있는데, 시작점과 끝점을 받아 시작점에서 출발해 끝점에 도달하는데 걸리는 횟수를 찾아내면 됐다.</p>
<p>어느쪽을 먼저 돌 것인지는 취향의 차이겠지만, 결국 어디에 끝점이 있을지 알 수 없기 때문에, 자식이 있는 노드의 경우 자식부터 시작해서 전부 찾은 후에, 없으면 부모쪽으로 올라가는 방식을 취했다. 이 때 부모 또한 있을지 없을 지 모르기때문에 부모가 있는 지도 확인해보고 올라가야된다.</p>
<p>촌수 계산이 형제와 부모 관계를 따로 따져야될 것처럼 보이지만, 실제로는 형제라면 부모쪽으로 올라갔다가 자식으로 내려오기 때문에 굳이 따로 따질 필요없이 부모 자식관계만으로 횟수를 제면 충분하다.</p>
<p>추가적으로 dfs가 끝났을 경우에도 추가로 더 돌지 않게 하려고 flag를 줘서 ty를 찾았을 경우 더 돌지 않고 돌아가도록 되어있다.</p>
</div></article></main><footer class="bg-white flex justify-center border rounded my-2"><div class="m-2"><a href="mailto:appn12@gmail.com"><img src="/images/email_icon.png" width="30" height="30"/></a></div><div class="m-2"><a href="https://github.com/OTKRyu"><img src="/images/GitHub-Mark-32px.png" width="30" height="30"/></a></div></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"backjoon_2644","contentHtml":"\u003ch1\u003ebackjoon_2644.py\u003c/h1\u003e\n\u003ch2\u003eproblem\u003c/h2\u003e\n\u003cp\u003e촌수계산[https://www.acmicpc.net/problem/2644]\u003c/p\u003e\n\u003ch2\u003eanswer\u003c/h2\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003en = int(input())\r\ntx, ty = map(int, input().split(\u0026#x26;#39; \u0026#x26;#39;))\r\nm = int(input())\r\nparents = {}\r\nchilds = {}\r\nresult = -1\r\ncheck = [1 for i in range(n+1)]\r\nfor i in range(m):\r\n    x, y = map(int, input().split(\u0026#x26;#39; \u0026#x26;#39;))\r\n    parents[y] = x\r\n    if childs.get(x):\r\n        childs[x].append(y)\r\n    else:\r\n        childs[x] = [y]\r\n\r\ndef dfs(tx, cnt):\r\n    global childs, parents, result, ty, check\r\n    check[tx] = 0\r\n    if tx == ty:\r\n        result = cnt\r\n        return 0\r\n    flag = 1\r\n    if childs.get(tx):\r\n        for child in childs[tx]:\r\n            if flag == 1 and check[child] == 1:\r\n                flag = dfs(child, cnt+1)\r\n    if parents.get(tx) and check[parents[tx]] == 1 and flag == 1:\r\n        return dfs(parents[tx], cnt+1)\r\n    return 1\r\n\r\ndfs(tx, 0)\r\nprint(result)\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch2\u003eexplanation\u003c/h2\u003e\n\u003cp\u003e촌수계산하는 문제이다.\u003c/p\u003e\n\u003cp\u003e여러 방법이 있겠지만, dfs 문제로 분류되어 있어서 dfs로 풀었다.\u003c/p\u003e\n\u003cp\u003e주어진 조건을 보면 일종의 트리를 만들 수 있는데, 시작점과 끝점을 받아 시작점에서 출발해 끝점에 도달하는데 걸리는 횟수를 찾아내면 됐다.\u003c/p\u003e\n\u003cp\u003e어느쪽을 먼저 돌 것인지는 취향의 차이겠지만, 결국 어디에 끝점이 있을지 알 수 없기 때문에, 자식이 있는 노드의 경우 자식부터 시작해서 전부 찾은 후에, 없으면 부모쪽으로 올라가는 방식을 취했다. 이 때 부모 또한 있을지 없을 지 모르기때문에 부모가 있는 지도 확인해보고 올라가야된다.\u003c/p\u003e\n\u003cp\u003e촌수 계산이 형제와 부모 관계를 따로 따져야될 것처럼 보이지만, 실제로는 형제라면 부모쪽으로 올라갔다가 자식으로 내려오기 때문에 굳이 따로 따질 필요없이 부모 자식관계만으로 횟수를 제면 충분하다.\u003c/p\u003e\n\u003cp\u003e추가적으로 dfs가 끝났을 경우에도 추가로 더 돌지 않게 하려고 flag를 줘서 ty를 찾았을 경우 더 돌지 않고 돌아가도록 되어있다.\u003c/p\u003e\n","title":"backjoon_2644.py","date":"2022-09-23","tags":["algorithm","python","backjoon","dfs"]}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"backjoon_2644"},"buildId":"3nolsCOkiLDS3NjSRQxxg","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>